Link: https://www.tutorialspoint.com/data_structures_algorithms/dsa_queue.htm


Queue: A series of arrivals tat need o be remembered. 
Process: Queue need to be processed. 

The balance between Queue and Process is a delicate choice. 

Data structures organize storage in computers so that we can efficiently access and change data 

As we move through the data structure types, the efficiency of the data structure would be a tradeoff.

1. List: 
A list is an ordered sequence of items with an incrementing index. Examples would be numpy array and python lists. Conviniently, we can call any emelement by simply calling the index number.But the problem with lists is that if you remove one entry, the it has to be reindexed to from the very beggining. This would be called O(n) with O with being a big O notation.   

2. Set: 
A set is not ordered and cannot contain duplicates. 

3. Linked lists: 
Here we preserve the order of the list without the index attached to it. However, each entry is linked to the next entry. Linked lists can be either singly or a doubly linked where singly link points only forward whereas double is pointed forward and backward. 

One advantage is deletion, which is O(n) for lists but only O(1) for linked lists. This is because we only update the pointer (or pointers in a doubly linked list) that was pointing to the removed item rather updating the index of every item that follows.
But if you want to access an entry, the efficiency is O(n) because we always have to start at the first item and move through the chain until we get to where we want. There is no fast way for us to go to a specific place since there is no index for us to reference. In data type, we've used Node class to create linked lists as python doesn't implement linked lists.



4. Queue: 
Works in a FiFO fashion: first in first out and last in last out. But it is open ended in both ends. One end is always used to insert data (enqueue) and the other is used to remove data (dequeue).

It is ordered like lists, but you'll only ever touch elements at one end. All elements get inserted at the "end" (enqueue) and removed from the "beginning" (or head) of the queue(dequeue -). You can find out how many elements are in the queue, but you can't find out what, say, the "third" element is. You'll see it when you get there. In other words, in accessing and searching, we'd fall into O(n) efficiency.

It is used when things donâ€™t have to be processed immediately, but have to be processed in First In First Out order. 

It is used when 1) When a resource is shared among multiple consumers. Examples include CPU scheduling, Disk Scheduling. 2) When data is transferred asynchronously (data not necessarily received at same rate as sent) between two processes. Examples include IO Buffers, pipes, file IO, etc.

5. Stacks:  Last-in-First-Out (LIFO) principle. It uses Push to add at the top of the stack and pop to remove it.

In python, we can use both list and deque(deck) library to crate and use Stacks and Queues. 

Example: Stacking

numbers = []

# Let's push some letters into our list
numbers.append(1)  
numbers.append(2)  
numbers.append(3)  
numbers.append(4)


last_item = numbers.pop()  
print(last_item)

last_item = umbers.pop()  
print(last_item)

# 1 and 2 remain
print(numbers)


Example: Queue

numbers = []

# Let's enqueue some numbers into our list
numbers.append('John')  
numbers.append('Jane')  
numbers.append('Mark')  
numbers.append('Matt')

# Now let's dequeue our numbers, we should get 'banana'
first_item = numbers.pop(0)  
print(first_item)


first_item = numbers.pop(0)  
print(first_item)


print(numbers)

Example: Using deque library

from collections import deque

# you can initialize a deque with a list 
numbers = deque()

# Use append like before to add elements
numbers.append(99)  
numbers.append(15)  
numbers.append(82)  
numbers.append(50)  
numbers.append(47)

# You can pop like a stack
last_item = numbers.pop()  
print(last_item) # 47  
print(numbers) # deque([99, 15, 82, 50])

# You can dequeue like a queue
first_item = numbers.popleft()  
print(first_item) # 99  
print(numbers) 
